// This test file was generated by AI.

import Testing
import simd

@testable import BrassBand

@MainActor
struct MeshTests {
    @Test func initialState() async throws {
        let mesh = Mesh()

        #expect(mesh.vertexData == nil)
        #expect(mesh.indexData == nil)
        #expect(mesh.texture == nil)
        #expect(mesh.color == Color(repeating: 1.0))
        #expect(mesh.isMeshColorUsed == false)
        #expect(mesh.primitiveType == .triangle)
        #expect(mesh.matrix == matrix_identity_float4x4)
    }

    @Test func vertexDataUpdate() async throws {
        let mesh = Mesh()
        let vertexData = MeshData<Vertex2d>(capacity: 3, dynamicBufferCount: 1)

        mesh.vertexData = vertexData
        #expect(mesh.vertexData != nil)
        #expect(mesh.vertexData === vertexData)
    }

    @Test func indexDataUpdate() async throws {
        let mesh = Mesh()
        let indexData = MeshData<Index2d>(capacity: 3, dynamicBufferCount: 1)

        mesh.indexData = indexData
        #expect(mesh.indexData != nil)
        #expect(mesh.indexData === indexData)
    }

    @Test func textureUpdate() async throws {
        let mesh = Mesh()
        let provider = ScaleFactorProviderStub()
        let texture = Texture(pointSize: .one, scaleFactorProvider: provider)

        mesh.texture = texture
        #expect(mesh.texture != nil)
        #expect(mesh.texture === texture)
    }

    @Test func colorUpdate() async throws {
        let mesh = Mesh()
        let newColor = Color(red: 1.0, green: 0.5, blue: 0.2, alpha: 1.0)

        mesh.color = newColor
        #expect(mesh.color == newColor)
    }

    @Test func meshColorUsedUpdate() async throws {
        let mesh = Mesh()

        mesh.isMeshColorUsed = true
        #expect(mesh.isMeshColorUsed == true)
    }

    @Test func primitiveTypeUpdate() async throws {
        let mesh = Mesh()

        mesh.primitiveType = .line
        #expect(mesh.primitiveType == .line)
    }

    @Test func matrixUpdate() async throws {
        let mesh = Mesh()
        let newMatrix = simd_float4x4([
            SIMD4<Float>(1, 0, 0, 0),
            SIMD4<Float>(0, 2, 0, 0),
            SIMD4<Float>(0, 0, 1, 0),
            SIMD4<Float>(0, 0, 0, 1),
        ])

        mesh.matrix = newMatrix
        #expect(mesh.matrix == newMatrix)
    }

    @Test func preRenderWithNoData() async throws {
        let mesh = Mesh()
        let result = mesh.preRender()
        #expect(result == false)
    }

    @Test func preRenderWithData() async throws {
        let mesh = Mesh()
        let vertexData = MeshData<Vertex2d>(capacity: 3, dynamicBufferCount: 1)
        let indexData = MeshData<Index2d>(capacity: 3, dynamicBufferCount: 1)

        mesh.vertexData = vertexData
        mesh.indexData = indexData

        let result = mesh.preRender()
        #expect(result == true)
    }

    @Test func fetchUpdatesAfterPropertyChanges() async throws {
        let mesh = Mesh()
        var treeUpdates = TreeUpdates()

        // 初期状態では全ての更新フラグが立っていることを確認
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates == .all)

        // 更新フラグをクリア
        mesh.clearUpdates()
        treeUpdates.meshUpdates = []
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.isEmpty)

        // vertexDataの更新
        let vertexData = MeshData<Vertex2d>(capacity: 3, dynamicBufferCount: 1)
        mesh.vertexData = vertexData
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.vertexData))

        // indexDataの更新
        treeUpdates.meshUpdates = []
        let indexData = MeshData<Index2d>(capacity: 3, dynamicBufferCount: 1)
        mesh.indexData = indexData
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.indexData))

        // textureの更新
        treeUpdates.meshUpdates = []
        let provider = ScaleFactorProviderStub()
        let texture = Texture(pointSize: .one, scaleFactorProvider: provider)
        mesh.texture = texture
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.texture))

        // colorの更新
        treeUpdates.meshUpdates = []
        mesh.color = Color(red: 1.0, green: 0.5, blue: 0.2, alpha: 1.0)
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.color))

        // isMeshColorUsedの更新
        treeUpdates.meshUpdates = []
        mesh.isMeshColorUsed = true
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.meshColorUsed))

        // primitiveTypeの更新
        treeUpdates.meshUpdates = []
        mesh.primitiveType = .line
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.primitiveType))

        // matrixの更新
        treeUpdates.meshUpdates = []
        mesh.matrix = simd_float4x4([
            SIMD4<Float>(1, 0, 0, 0),
            SIMD4<Float>(0, 2, 0, 0),
            SIMD4<Float>(0, 0, 1, 0),
            SIMD4<Float>(0, 0, 0, 1),
        ])
        mesh.fetchUpdates(&treeUpdates)
        #expect(treeUpdates.meshUpdates.contains(.matrix))
    }

    @Test func fetchUpdatesWithMeshDataUpdates() async throws {
        let mesh = Mesh()
        var treeUpdates = TreeUpdates()

        // MeshDataの更新が伝播することを確認
        let vertexData = MeshData<Vertex2d>(capacity: 3, dynamicBufferCount: 1)
        let indexData = MeshData<Index2d>(capacity: 3, dynamicBufferCount: 1)

        mesh.vertexData = vertexData
        mesh.indexData = indexData

        // MeshDataの内容を更新
        vertexData.write { (buffer: UnsafeMutableBufferPointer<Vertex2d>) in
            buffer[0].position = SIMD2<Float>(x: 1.0, y: 1.0)
        }
        indexData.write { (buffer: UnsafeMutableBufferPointer<Index2d>) in
            buffer[0] = 1
        }

        mesh.fetchUpdates(&treeUpdates)

        // vertexDataとindexDataの更新が反映されていることを確認
        #expect(!treeUpdates.vertexDataUpdates.isEmpty)
        #expect(!treeUpdates.indexDataUpdates.isEmpty)
    }
}

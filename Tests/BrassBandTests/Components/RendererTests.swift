// This test file was generated by AI.

import Combine
import Testing
import os

@testable import BrassBand

private final class ViewLookStub: Renderer.ViewLook {
    var background: Background = .init()
    var projectionMatrix: simd_float4x4 = matrix_identity_float4x4
}

private final class SystemStub: Renderer.System {
    var viewRenderCalled = false
    var lastProjectionMatrix: simd_float4x4?
    var lastRootNode: Node?
    var lastDetector: (any Renderer.Detector)?

    func viewRender(
        projectionMatrix: simd_float4x4,
        rootNode: Node,
        detector: any DetectorForRenderInfo
    ) {
        viewRenderCalled = true
        lastProjectionMatrix = projectionMatrix
        lastRootNode = rootNode
        lastDetector = detector as? any Renderer.Detector
    }
}

private final class DetectorStub: Renderer.Detector, DetectorForRenderInfo {
    var beginUpdateCalled = false
    var endUpdateCalled = false
    private(set) var isUpdating: Bool = false
    private var colliders: [Collider] = []

    func beginUpdate() {
        beginUpdateCalled = true
        isUpdating = true
    }

    func endUpdate() {
        endUpdateCalled = true
        isUpdating = false
    }

    func add(collider: Collider) {
        guard isUpdating else { return }
        colliders.append(collider)
    }
}

private final class ActionStub: Renderer.Action {
    private struct Protected {
        var updateCalled: Bool = false
        var lastUpdateDate: Date?
        var shouldUpdate: Bool = true
    }

    private let lock = OSAllocatedUnfairLock(initialState: Protected())

    var updateCalled: Bool {
        get { lock.withLock { $0.updateCalled } }
        set { lock.withLock { $0.updateCalled = newValue } }
    }

    var lastUpdateDate: Date? {
        get { lock.withLock { $0.lastUpdateDate } }
        set { lock.withLock { $0.lastUpdateDate = newValue } }
    }

    var shouldUpdate: Bool {
        get { lock.withLock { $0.shouldUpdate } }
        set { lock.withLock { $0.shouldUpdate = newValue } }
    }

    func update(_ date: Date) -> Bool {
        lock.withLock { state in
            state.updateCalled = true
            state.lastUpdateDate = date
            return state.shouldUpdate
        }
    }
}

@MainActor
final class RendererTests {
    private var cancellables: Set<AnyCancellable> = []
    private let viewLook = ViewLookStub()
    private let system = SystemStub()
    private let detector = DetectorStub()
    private let action = ActionStub()
    private let rootNode = Node.content

    @Test
    func basicRendering() {
        let renderer = Renderer(
            rootNode: rootNode,
            viewLook: viewLook,
            system: system,
            detector: detector,
            action: action
        )

        // コライダーを更新してisColliderUpdatedをtrueにする
        rootNode.colliders = [
            Collider(shape: RectShape(rect: .init(center: .zero, size: .init(repeating: 1.0))))
        ]

        renderer.viewRender()

        #expect(system.viewRenderCalled)
        #expect(system.lastProjectionMatrix == viewLook.projectionMatrix)
        #expect(system.lastRootNode === rootNode)
        #expect(system.lastDetector === detector)
        #expect(detector.beginUpdateCalled)
        #expect(detector.endUpdateCalled)
        #expect(action.updateCalled)
    }

    @Test
    func eventPublishing() {
        let renderer = Renderer(
            rootNode: rootNode,
            viewLook: viewLook,
            system: system,
            detector: detector,
            action: action
        )

        var willRenderCalled = false
        var didRenderCalled = false
        var backgroundColorReceived: Color?

        renderer.willRender
            .sink { _ in willRenderCalled = true }
            .store(in: &cancellables)

        renderer.didRender
            .sink { _ in didRenderCalled = true }
            .store(in: &cancellables)

        renderer.backgroundColor
            .sink { color in backgroundColorReceived = color }
            .store(in: &cancellables)

        renderer.viewRender()

        #expect(willRenderCalled)
        #expect(didRenderCalled)
        #expect(backgroundColorReceived == viewLook.background.color)
    }

    @Test
    func updateHandling() {
        let renderer = Renderer(
            rootNode: rootNode,
            viewLook: viewLook,
            system: system,
            detector: detector,
            action: action
        )

        // 更新が必要な場合
        action.shouldUpdate = true
        renderer.viewRender()
        #expect(system.viewRenderCalled)

        // 更新が不要な場合
        system.viewRenderCalled = false
        action.shouldUpdate = false
        renderer.viewRender()
        #expect(!system.viewRenderCalled)
    }
}
